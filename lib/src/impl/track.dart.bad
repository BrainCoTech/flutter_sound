import 'dart:async';

import '../audio.dart';
import '../codec.dart';
import '../playback_disposition.dart';
import '../sound_player.dart';
import 'track_impl.dart';

typedef TrackAction = void Function(Track current);

/// Should we abstract a track from how it gets played.
/// I've never liked the hard link between a track
/// and the OS playback mechanism.
///
/// So what I want is for:
/// SoundPlayer - just plays audio no UI.
///  - able to send events so you can implement your own audio.
///
/// Track - allows you to define additional info such as artist
///   but you can also provide a UI manager
///   - the problem is that the plugin architecture is awkard for this
///     as it encapsulates play back and the UI.
///
/// AudioSession - we pass this around to create a coherent
/// session.
/// A SoundPlayer gets a session when it is initialised unless
/// one is passed to it.
/// An album creates a session and passes it to a Track/SoundPlayer
///

///
/// The [Track] class lets you define an audio track.
///
/// An implementation has been used to hide a number of api
/// calls that need to be visible to other classes but which
/// are not part of our public api.
///
class Track {
  TrackImpl _impl;

  /// The title of this track
  set trackTitle(String title) => _impl.trackTitle;

  /// The title of this track
  String get trackTitle => _impl.trackTitle;

  /// The name of the author of this track
  String get trackAuthor => _impl.trackAuthor;

  /// The name of the author of this track
  set trackAuthor(String trackAuthor) => _impl.trackAuthor = trackAuthor;

  /// The URL that points to the album art of the track
  String get albumArtUrl => _impl.albumArtUrl;

  /// The URL that points to the album art of the track
  set albumArtUrl(String albumArtUrl) {
    _impl.albumArtUrl = albumArtUrl;
  }

  /// The asset that points to the album art of the track
  String get albumArtAsset => _impl.albumArtAsset;

  /// The asset that points to the album art of the track
  set albumArtAsset(String albumArtAsset) {
    _impl.albumArtAsset = albumArtAsset;
  }

  ///
  Track.fromPath(String url, {Codec codec}) {
    _impl = TrackImpl.fromAudio(AudioTrackURI(url, codec, this));
  }

  /// Starts the track playig
  Future<void> play() => _impl.play();

  /// pauses the track.
  Future<void> pause() => _impl.pause();

  /// resumes the track playing
  Future<void> resume() => _impl.resume();

  /// Stops the track playing reseting the
  /// playback postion to zero.
  Future<void> stop() => _impl.stop();

  /// seeks the track to the given position.
  /// This can be called before or during playback.
  Future<void> seekTo(Duration position) => _impl.seekTo(position);

  /// Once you have finished with the [Track] you MUST
  /// call [release] otherwise you will leak resources.
  Future<void> release() => _impl.release();

  /// Sets the playback volume.
  /// The [volume] must be between 0.0 and 1.0.
  ///
  /// A value of 11 will be ignored except in your mind.
  Future<void> setVolume(double volume) => _impl.setVolume(volume);

  /// If you need to track the position of the playback
  /// then you use [dispositionStream] to recieve a stream
  /// of [PlaybackDispositions].
  Stream<PlaybackDisposition> dispositionStream(
          {Duration interval = const Duration(milliseconds: 100)}) =>
      _impl.dispositionStream(interval: interval);

  /// returns true if the track is currently playing
  bool get isPlaying => _impl.isPlaying;

  /// returns true if the track is currently paused
  bool get isPaused => _impl.isPaused;

  /// returns true if the track is currently stopped.
  /// Note: this is not the same as being paused.
  bool get isStopped => _impl.isStopped;

  set hushOthers(bool hush) => _impl.hushOthers = hush;

  /// Makes this track's audio the foreground audio.
  Future<void> requestAudioFocus({bool enabled}) => _impl.requestAudioFocus();

  /// Reliquences the foreground audio.
  Future<void> abandonAudioFocus({bool enabled}) => _impl.abandonAudioFocus();

  set onStarted(PlayerEvent event) => _impl.onStarted;
  set onFinished(PlayerEvent event) => _impl.onFinished;
  set onStopped(PlayerEvent event) => _impl.onStopped;
  set onPaused(PlayerEvent event) => _impl.onPaused;
  set onResumed(PlayerEvent event) => _impl.onResumed;
}
